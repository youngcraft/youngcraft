---
layout:     post
title:      GDB_peda插件使用指南
subtitle:   exploit调试
date:       2017-08-10
author:     Ytala
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - Blog
---




# GDB-peda 神器 利用命令

    Key Features:
    
    Enhance the display of gdb: colorize and display disassembly codes, registers, memory information during debugging.
    Add commands to support debugging and exploit development (for a full list of commands use peda help):
    aslr -- Show/set ASLR setting of GDB
    checksec -- Check for various security options of binary
    dumpargs -- Display arguments passed to a function when stopped at a call instruction
    dumprop -- Dump all ROP gadgets in specific memory range
    elfheader -- Get headers information from debugged ELF file
    elfsymbol -- Get non-debugging symbol information from an ELF file
    lookup -- Search for all addresses/references to addresses which belong to a memory range
    patch -- Patch memory start at an address with string/hexstring/int
    pattern -- Generate, search, or write a cyclic pattern to memory
    procinfo -- Display various info from /proc/pid/
    pshow -- Show various PEDA options and other settings
    pset -- Set various PEDA options and other settings
    readelf -- Get headers information from an ELF file
    ropgadget -- Get common ROP gadgets of binary or library
    ropsearch -- Search for ROP gadgets in memory
    searchmem|find -- Search for a pattern in memory; support regex search
    shellcode -- Generate or download common shellcodes.
    skeleton -- Generate python exploit code template
    vmmap -- Get virtual mapping address ranges of section(s) in debugged process
    xormem -- XOR a memory region with a key


    用gdb查看内存
    格式: x /nfu
    说明
    x 是 examine 的缩写
    n表示要显示的内存单元的个数
    f表示显示方式, 可取如下值
    x 按十六进制格式显示变量。
    d 按十进制格式显示变量。
    u 按十进制格式显示无符号整型。
    o 按八进制格式显示变量。
    t 按二进制格式显示变量。
    a 按十六进制格式显示变量。
    i 指令地址格式
    c 按字符格式显示变量。
    f 按浮点数格式显示变量。
    u表示一个地址单元的长度
    b表示单字节，
    h表示双字节，
    w表示四字节，
    g表示八字节

	常用方法：
	x/16xw (address) 以16个内存单元，x表示十六进制显示，w表示四字节
	x/8xh  (address) 以8个内存单元，x表示十六进制显示，h表示两字节
    x/8ih  (address) 以8个内存单位，i表示地址格式表示，主要用于GOT表，PIT表中地址表示，h表示两字节。
	
	   gdb-peda$ x/16iw 0x8048380
       0x8048380 <read@plt>:	jmpDWORD PTR ds:0x804a000
       0x8048386 <read@plt+6>:	push   0x0
    => 0x804838b <read@plt+11>:	jmp0x8048370
       0x8048390 <getegid@plt>:	jmpDWORD PTR ds:0x804a004
       0x8048396 <getegid@plt+6>:	push   0x8
       0x804839b <getegid@plt+11>:	jmp0x8048370
       0x80483a0 <system@plt>:	jmpDWORD PTR ds:0x804a008
       0x80483a6 <system@plt+6>:	push   0x10
       0x80483ab <system@plt+11>:	jmp0x8048370
       0x80483b0 <__gmon_start__@plt>:	jmpDWORD PTR ds:0x804a00c
       0x80483b6 <__gmon_start__@plt+6>:	push   0x18
       0x80483bb <__gmon_start__@plt+11>:	jmp0x8048370
       0x80483c0 <__libc_start_main@plt>:	jmpDWORD PTR ds:0x804a010
       0x80483c6 <__libc_start_main@plt+6>:	push   0x20
       0x80483cb <__libc_start_main@plt+11>:	jmp0x8048370
       0x80483d0 <write@plt>:	jmpDWORD PTR ds:0x804a014


    
    Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),
    t(binary), f(float), a(address), i(instruction), c(char) and s(string).
    Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes)
    举例
    x/3uh buf 
    表示从内存地址buf读取内容，
    h表示以双字节为一个单位，
    3表示三个单位，
    u表示按十六进制显示
    例子：
    n是个局部变量
    Breakpoint 1, main (argc=1, argv=0xbffff3a4) at calc.c:7
    7int n = atoi(argv[1]);
    (gdb) print &n
    $1 = (int *) 0xbffff2ec
    (gdb) x 0xbffff2ec
    0xbffff2ec:0x00282ff4
    (gdb) print * (int *) 0xbffff2ec
    $2 = 2633716
    (gdb) x /4xw 0xbffff2ec
    0xbffff2ec:0x00282ff40x080484e00x000000000xbffff378
    (gdb) x /4dw 0xbffff2ec
    0xbffff2ec:26337161345138880-1073745032
    (gdb)

    设定参数，输入的参数设置

    pset arg 'cyclic_pattern(300)'
    
    

# linux 指令


## ldd 

查询bin文件依赖

    ubuntu:~/Desktop/pwntools_test$ ldd section_test
    linux-gate.so.1 =>  (0xf7728000)
	libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7554000)
	/lib/ld-linux.so.2 (0x5660a000)

## 查询libc.so 版本号


[https://github.com/niklasb/libc-database](https://github.com/niklasb/libc-database)  用来查询libc版本信息内容，为exp提供方便

[http://libcdb.com/](http://libcdb.com/)
网上查询版本


## checksec 检测保护方式

我们最常见的保护明星

    CANARY: disabled
    FORTIFY   : disabled
    NX: ENABLED
    PIE   : disabled
    RELRO : Partial
    


### GANNARY（栈保护）

Windows下以security cookie形式存在，这个选项表示栈保护功能有没有开启。

栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。

gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。

因此在编译时可以控制是否开启栈保护以及程度，例如：

    gcc -fno-stack-protector -o test test.c  //禁用栈保护
    gcc -fstack-protector -o test test.c   //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码
    gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码

### FORTIFY 

。。。。。。

### NX（DEP）

堆栈不可执行，通过修改页属性，不能执行代码。NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。

![](http://i.imgur.com/mwQwzQF.jpg)


### ASLR（PIE）

一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。

内存地址随机化机制（address space layout randomization)，有以下三种情况

- 0 表示关闭进程地址空间随机化。
- 1 表示将mmap的基址，stack和vdso页面随机化。
- 2 表示在1的基础上增加栈（heap）的随机化。

可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。

Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。

liunx下关闭PIE的命令如下：

sudo -s echo 0 > /proc/sys/kernel/randomize_va_space

确认ASLR是否已经被打开，"2"表示已经打开

[plain] view plaincopy
shanks@shanks-ubuntu:/home/shanks# cat /proc/sys/kernel/randomize_va_space   
2  

/proc/sys/kernel/randomize_va_space

切换到root用户来做更新，直接使用sudo会出现下面结果


In any ASLR enabled binary (and most normal binaries for that
matter) there has to be a way for the binary to 'know' where the libc functions
are at. The binary creates a PLT stub for functions used in the source. These
are **always at a constant address**. This PLT stub is essentially a wrapper
function for the actual function in libc. The GOT contains the actual adresses
in libc for the functions used in the program. The actual adresses change from
runtime to runtime, but pointers to the same function are **always in the same
spot in the GOT**.

