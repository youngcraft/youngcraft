---
title: 初探wavpack测试crashes样本分析
date: 2022-05-14 08:42:53
tags:
categories:   
    - 模糊测试
---

# wavpack crash文件分析

最近使用afl对wavpack进行了一次模糊测试，跑出来了15个crashes,针对其中test09.wav样本进行一下分析。如有错误请各位大佬多多指教。

## crash09-关于id_000009,sig_11,src_001266,time_25197388,op_havoc,rep_16

系统栈帧崩溃时的backtrace如下：

```
gdb-peda$ bt
#0  __memmove_avx_unaligned_erms () at ../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:416
#1  0x00007ffff7a2438e in __GI__IO_file_xsgetn (fp=0x555555675580, data=<optimized out>, n=0x95959596) at fileops.c:1304
#2  0x00007ffff7a17f13 in __GI__IO_fread (buf=0x0, size=size@entry=0x1, count=count@entry=0x95959596, fp=fp@entry=0x555555675580) at iofread.c:38
#3  0x00005555555b4cd6 in fread (__stream=0x555555675580, __n=0x95959596, __size=0x1, __ptr=<optimized out>) at /usr/include/x86_64-linux-gnu/bits/stdio2.h:297
#4  DoReadFile (hFile=hFile@entry=0x555555675580, lpBuffer=lpBuffer@entry=0x0, nNumberOfBytesToRead=nNumberOfBytesToRead@entry=0x95959596, 
    lpNumberOfBytesRead=lpNumberOfBytesRead@entry=0x7fffffffba0c) at utils.c:618
#5  0x000055555559c086 in ParseRiffHeaderConfig (infile=0x555555675580, infilename=0x5555556752c0 "test09.wav", fourcc=<optimized out>, wpc=0x555555675300, 
    config=0x7fffffffbc60) at riff.c:296
#6  0x0000555555599386 in pack_file (infilename=0x5555556752c0 "test09.wav", outfilename=0x5555556752e0 "test09.wv", out2filename=0x0, config=<optimized out>)
    at wavpack.c:1776
#7  0x000055555555af58 in main (argc=<optimized out>, argc@entry=0x3, argv=<optimized out>, argv@entry=0x7fffffffe338) at wavpack.c:1272
#8  0x00007ffff79b90b3 in __libc_start_main (main=0x555555557600 <main>, argc=0x3, argv=0x7fffffffe338, init=<optimized out>, fini=<optimized out>, 
    rtld_fini=<optimized out>, stack_end=0x7fffffffe328) at ../csu/libc-start.c:308
#9  0x000055555556d8ee in _start ()

```
其中，#3,#4分别表示在fread和utils.c 618行函数DoReadFile出现错误，从具体调用关系上看，#4在调用#3过程中，需要调用fread函数，fread函数的标准释义是：

> size_t fread( void *restrict buffer, size_t size, size_t count, FILE *restrict stream );

其中restrict buffer表示要拷贝数据，从steam中读取size*count个字节数据到buffer中，在执行文件中发现 实际参数值为buf=0x0, size=size@entry=0x1, count=count@entry=0x95959596, fp=fp@entry=0x555555675580。一般而言，系统函数库中的函数一般不会出错的，出错的问题在于我们调用时使用了不正确的参数或者地址，导致系统出错。跟着bt的结果，我们一步步发掘系统报段错误的原因：

-----------------------------

### 一步步分析崩溃原因

崩溃前最后一个自写的函数就是DoReadFile，函数调用参数分别如下
 (buf=0x0, size=size@entry=0x1, count=count@entry=0x95959596, fp=fp@entry=0x555555675580) 

```
Breakpoint 1, DoReadFile (hFile=hFile@entry=0x555555675580, 
    lpBuffer=lpBuffer@entry=0x7fffffffbb4c, 
    nNumberOfBytesToRead=nNumberOfBytesToRead@entry=0x8, 
    lpNumberOfBytesRead=lpNumberOfBytesRead@entry=0x7fffffffbb1c) at utils.c:620

0x000055555559b3fa in ParseRiffHeaderConfig (infile=0x555555675580, 
    infilename=0x455641570003877c <error: Cannot access memory at address 0x455641570003877c>, fourcc=<optimized out>, wpc=0x555555675300, config=0x7fffffffbd70) at riff.c:75
75          if ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) ||
```


#### 转储Core dump文件

core转储文件可以用于发现具体错误点，core dump文件需要提前设置，这里不再过多赘述。从分析core dump文件开始，发现报错是出现了glibc文件之中。

```bash
Core was generated by `./cli/wavpack -y test09.wav'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  __memmove_avx_unaligned_erms () at ../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:416
```

出错的代码部分，fileops.c:1304行，glibc版本为2.3.1，在线链接是：https://elixir.bootlin.com/glibc/glibc-2.31/source/libio/fileops.c：

```c


  while (want > 0)
    {
    
      have = fp->_IO_read_end - fp->_IO_read_ptr;
      if (want <= have)   ## 第二部分，输入缓冲区里已经有足够的字符，则直接把缓冲区里的字符给目标buff
  {
    memcpy (s, fp->_IO_read_ptr, want);
    fp->_IO_read_ptr += want;
    want = 0;
  }
   else
  {
    if (have > 0)  ## 第三部分，输入缓冲区里有部分字符，但是没有达到fread的size需求，先把已有的拷贝至目标buff
      {
        memcpy (s, fp->_IO_read_ptr, have);  <<<============程序运行到这一步报错，fileops.c：1304行
        s += have;
        want -= have;
        fp->_IO_read_ptr += have;
      }
    
```

&emsp;&emsp;在memcpy函数拷贝数据出现越界，第1个参数*s为数据data，拷贝的目标地址，第二个fp参数，拷贝的源地址，fp->_IO_read_ptr是FILE结构体的一部分，偏移为8，表示读取的起始地址。have表示传入数据长度。在IO_FILE结构体中，fp也是一个IO_FILE结构体，遵从IO_FILE标准结构。

![代码报错fileops.c:1304](/img/wavpack代码行1.png)

&emsp;&emsp;程序运行逻辑中，have表示实际能够存储的内存大小，want表示当前传入的参数，报错上下文也就是want = 0x95959596。此时，have < want,因此，程序进入if (have > 0)对应的逻辑块，程序直接

&emsp;&emsp;可以看到file类型的fp函数IO_read_ptr地址偏移为8，通过gdb-peda看到fp第二个地址为_IO_read_ptr=0x555555676258,最大读指针地址_IO_read_end=0x55555555676940，其中可读取空间包括0x940-0x258=0x6E8个地址空间。memcpy如果执行复制n=0x95959596后，_IO_read_ptr（0x555555676258）+ n（0x95959596）= 0x5555EAFCF7EE > 程序所在内存空间，导致覆盖了0x0x555555676258~0x55555EAFCF7EE范围的数据，这一覆盖范围远远大于映射的内存区域，导致出现段错误，因此系统报错。


#### IO_FILE文件结构 
参考知识：_IO_FILE结构体可以看到，IO_read_ptr在地址偏移8字节位置，IO_read_end在偏移16字节的位置，一般情况下IO_read_ptr和IO_read_base保持一致。
```C
struct _IO_FILE
{
  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */  // 0偏移，8字节

  /* The following pointers correspond to the C++ streambuf protocol. */ //8偏移，8字节
  char *_IO_read_ptr;	/* Current read pointer */
  char *_IO_read_end;	/* End of get area. */
  char *_IO_read_base;	/* Start of putback+get area. */
  char *_IO_write_base;	/* Start of put area. */
  char *_IO_write_ptr;	/* Current put pointer. */
  char *_IO_write_end;	/* End of put area. */
  char *_IO_buf_base;	/* Start of reserve area. */
  char *_IO_buf_end;	/* End of reserve area. */

  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
```


查看FILE结构体中各字段的具体数值，遵从小端模式：
```bash
gdb-peda$ x/32w 0x555555675580
0x555555675580: 0xfbad2488      0x00000000      0x55676258      0x00005555
0x555555675590: 0x55676940      0x00005555      0x55675940      0x00005555
0x5555556755a0: 0x55675940      0x00005555      0x55675940      0x00005555
0x5555556755b0: 0x55675940      0x00005555      0x55675940      0x00005555
```

vmmap查看当前系统能够使用的内存区域,如下方系统显示，不管是超出内存区复制数据抑或覆盖的数据超过现内存边界，都会产生段错误。
```
gdb-peda$ vmmap
Start              End                Perm      Name
0x0000555555554000 0x0000555555557000 r--p      /home/pwn/aflsmart/WavPack/cli/wavpack
0x0000555555557000 0x0000555555665000 r-xp      /home/pwn/aflsmart/WavPack/cli/wavpack
0x0000555555665000 0x0000555555673000 r--p      /home/pwn/aflsmart/WavPack/cli/wavpack
0x0000555555673000 0x0000555555674000 r--p      /home/pwn/aflsmart/WavPack/cli/wavpack
0x0000555555674000 0x0000555555675000 rw-p      /home/pwn/aflsmart/WavPack/cli/wavpack

0x00007ffff7993000 0x00007ffff7994000 r--p      /usr/lib/x86_64-linux-gnu/libdl-2.31.so
0x00007ffff7994000 0x00007ffff7995000 rw-p      /usr/lib/x86_64-linux-gnu/libdl-2.31.so
0x00007ffff7995000 0x00007ffff79b7000 r--p      /usr/lib/x86_64-linux-gnu/libc-2.31.so
0x00007ffff79b7000 0x00007ffff7b2f000 r-xp      /usr/lib/x86_64-linux-gnu/libc-2.31.so
0x00007ffff7b2f000 0x00007ffff7b7d000 r--p      /usr/lib/x86_64-linux-gnu/libc-2.31.so
0x00007ffff7b7d000 0x00007ffff7b81000 r--p      /usr/lib/x86_64-linux-gnu/libc-2.31.so
0x00007ffff7b81000 0x00007ffff7b83000 rw-p      /usr/lib/x86_64-linux-gnu/libc-2.31.so
0x00007ffff7b83000 0x00007ffff7b87000 rw-p      mapped

```

# 验证思想

在GDB挂载进程后，对进程内存中参数修改，修改了stack中地址，查看调用是否满足相关需求。？


# 问题分析


```
   0x7ffff7b2077f <__memmove_avx_unaligned_erms+399>:	lea    rcx,[rdi+rdx*1-0x20]
   0x7ffff7b20784 <__memmove_avx_unaligned_erms+404>:	mov    r8,rdi  //r8=
   0x7ffff7b20787 <__memmove_avx_unaligned_erms+407>:	and    r8,0x1f
=> 0x7ffff7b2078b <__memmove_avx_unaligned_erms+411>:	sub    r8,0x20
```
R8在执行sub命令前为0x00，因此减去0x20导致异常，R8变为0xffffffffffffffe0

由于sub R8,0x20,R8=0后，导致 R8:0xffffffffffffffe0，后续对寄存器操作均使用R8寄存器进行计算。

```
=> 0x7ffff7a24380 <__GI__IO_file_xsgetn+272>:	mov    rdi,r13
   0x7ffff7a24383 <__GI__IO_file_xsgetn+275>:	mov    rdx,rbp
   0x7ffff7a24386 <__GI__IO_file_xsgetn+278>:	sub    r12,rbp
```
在执行到这一行代码时，rbp、r13、r12进行计算，需要使用

（1）vmovdqu 指令的具体作用，导致这个问题出现的主要原因，以及如何避免这种问题。

# 对若干问题的深究

1.对寄存器掌握不深，对x64环境下各个寄存器的功能不熟悉。


|第64位|第32位|第16位|第8位|一般作用|
|------|------|------|-----|------|
|63|31|15|7|0|
|%rax|%eax|%ax|%al|返回值|
|%rbx|%ebx|%bx|%bl|被调用者保存|
|%rcx|%ecx|%cx|%cl|第四个参数
|%rdx|%edx|%dx|%dl|第三个参数
|%rsi|%esi|%si|%sil|第二个参数
|%rdi|%edi|%di|%dil|第一个参数
|%rbp|%ebp|%bp|%bpl|被调用者保存
|%rsp|%esp|%sp|%spl|栈指针
|%r8|%r8d|%r8w|%r8b|第五个参数
|%r9|%r9d|%r9w|%r9b|第六个参数
|%r10|%r10d|%r10w|%r10b|调用者保存
|%r11|%r11d|%r11w|%r11b|调用者保存
|%r12	|%r12d	|%r12w	|%r12b	|被调用者保存
|%r13	|%r13d	|%r13w	|%r13b	|被调用者保存
|%r14	|%r14d	|%r14w	|%r14b	|被调用者保存
|%r15	|%r15d	|%r15w	|%r15b	|被调用者保存

其中，字节级操作可以访问最低的字节，16位操作可以访问最低的2个字 节32位操作可以访问最低的4个字节，而64位操作可以访问整个寄存器




# 课后温习

1. fread函数的详细实现讲解  https://ray-cp.github.io/archivers/IO_FILE_fread_analysis
2. glibc-2.3.1下fileops.c的实现  https://elixir.bootlin.com/glibc/glibc-2.31/source/libio/fileops.c