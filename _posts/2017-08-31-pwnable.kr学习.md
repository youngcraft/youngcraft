

## passcode 

知识点： 
scanf函数输入问题，会把栈上存储内容的地址作为&地址来使用
GOT 复写技术，讲GOT中的偏移写入system地址附近，然后函数在调用下一某个函数（printf，fflush等函数的时候），反正是在这次scanf之后存在的某个函数


	 804858b:    a1 2c a0 04 08           mov    0x804a02c,%eax
	 8048590:    89 04 24                 mov    %eax,(%esp)
	 8048593:    e8 98 fe ff ff           call   8048430 <fflush@plt>
	 8048598:    b8 86 87 04 08           mov    $0x8048786,%eax
	 804859d:    89 04 24                 mov    %eax,(%esp)
	 80485a0:    e8 7b fe ff ff           call   8048420 <printf@plt>

复写printf()函数
http://m.blog.csdn.net/qq_33528164/article/details/70505151

复写fflush函数，同样的方法，讲fflush的GOT表中的地址覆盖成system地址

攻击实现的前提：GOT可改，可以通过函数实现对GOT的改写

如何发现漏洞：编译c文件，往往编译器给的提示就是错误信息

	root@ubuntu:~/Desktop/pwnable_kr/passcode# gcc -o password1 passcode.c
	passcode.c: In function ‘login’:
	passcode.c:9:8: warning: format ‘%d’ expects argument of type ‘int *’, but argument 2 has type ‘int’ [-Wformat=]
	  scanf("%d", passcode1);
	        ^
	passcode.c:14:15: warning: format ‘%d’ expects argument of type ‘int *’, but argument 2 has type ‘int’ [-Wformat=]
	         scanf("%d", passcode2);

可以第二个参数存在问题，需要&取地址符号，没有就导致了scanf把esp开辟的栈空间中的地址当做需要写入的地址来执行，当前会报段错误！！！！

# random 

知识点：rand()随机化在同一主机是不会改变的，gdb一下就可以得到结果


# input2

知识点：对linux文件输入参数的考察，输入的参数包括形参数量，参数本身，环境变量，文件读写，stdio输入输出，pipe管道输入参数等等。

# leg 

知识点：ARM汇编
参考：
http://www.tuicool.com/articles/bERfu2m 相对比较详细
http://blog.csdn.net/qq_19550513/article/details/62044968 
http://blog.csdn.net/lee244868149/article/details/49488575 ARM指针PC相关小问题（学习之）


具体知识点：

其他：
ARM状态此时处理器执行32位的字对齐的ARM指令，Thumb状态此时处理器执行16位的，半字对齐的THUMB指令。 切换程序：从ARM到Thumb: LDR R0,=lable+1 BX R0 从ARM到Thumb: LDR R0,=lable BX R0

key1：

arm汇编是以r0作为函数的返回值的，pc的值为当前地址+8 即0x00008cdc+ 8

key2：
	0x00008d00 <+16>:    bx      r6                                          
	0x00008d04 <+20>:    mov     r3, pc                                      
	0x00008d06 <+22>:    adds    r3, #4   
	......
0x00008d10  <+32>:   mov r0, r3
r6 = 0x00008cfc + 8 +1 = 0x00008d04。 bx r6在r6地址处切换成thumb模式。在thumb模式下pc = 当前地址+4。r0 =r3 = 0x00008d04 +4+4

key3：

	0x00008d28 <+8>:     mov     r3, lr                                        
	0x00008d2c <+12>:    mov     r0, r3
r0等于lr即key3()函数的返回地址0x00008d80。

特殊点：
lr地址的问题：
参考http://blog.csdn.net/lee244868149/article/details/49488575，根据不同的指令，lr地址会变化，

因此得到值为：
0x8ce4+0x8d0c+0x8d80=108400(d)

# mistake

知识点：

	if(fd=open("/home/mistake/password",O_RDONLY,0400) < 0){
	if(!(len=read(fd,pw_buf,PW_LEN) > 0)){

In C, the file descriptor 0 indicates the stdin file stream. Because fd is always 0, read() will copy the content of the stdin stream to pw_buf!
C原因中，<  > 的优先级比=高，因此，这个话永远也是fd=0，当fd=0时，表示从stdio中输入，因此第一个我们可以从标准输入输入一个长度为10的字符串，然后异或后：

	mistake@ubuntu:~$ ./mistake
	do not bruteforce...
	0000000000
	111input password :1111111111
	Password OK
	Mommy, the operator priority always confuses me :(



# shellshock 

CVE-2014-6271 

http://ydc1992.github.io/2016/04/03/Pwnable-kr-shellshock/
http://devco.re/blog/2014/09/30/shellshock-CVE-2014-6271/
https://coolshell.cn/articles/11973.html



挖掘该漏洞的方法论： 深入了解bash源码，对bash处理env了如执掌啊

env 环境变量的处理问题，(){ 会被处理成为函数开头，虽然你输入的只是参数，导致代码注入，可以开个反向端口或者shell
一般常用的payload是：

	'(){:;};echo flag'
	':'相当于/bin/true 
    () { :;} 中的冒号就相当于/bin/true，返回true并退出。

构造payload：

    env x='() { :;}; /bin/cat flag' ./shellshock




# coin1 

竞争游戏













               ^
