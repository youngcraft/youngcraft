---
layout:     post
title:      C库函数学习
subtitle:   C语言的文化根底还是很重要的
date:       2017-08-04
author:     BY TALA
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - Blog
---


> C语言很神奇



# C库函数学习

----------
学习C库函数是阅读pwn题IDA反汇编代码的关键，如何对关键函数部署很难做C

## setvbuff函数


    #include <stdio.h>

包含在stdio.h文件内，
用 法: int setvbuf(FILE *stream, char *buf, int type, unsigned size);

- stream ：指向流的指针 ；
- buf ： 期望缓冲区的地址；
- type ： 期望缓冲区的类型：

_IOFBF(满缓冲，符号表示为0）：当缓冲区为空时，从流读入数据。或者当缓冲区满时，向流写入数 据。

_IOLBF(行缓冲，数字表示为）：每次从流中读入一行数据或向流中写入一行数据。

_IONBF(无缓冲）：直接从流中读入数据或直接向流中写入数据，而没有缓冲区。

- 　　size ： 缓冲区内字节的数量。 

其中，setvbuf参数宏定义为：

    /* The possibilities for the third argument to `setvbuf'.  */
    #define _IOFBF 0		/* Fully buffered.  */
    #define _IOLBF 1		/* Line buffered.  */
    #define _IONBF 2		/* No buffering.  */
# 
# 程序符号__gmon_start__



# read函数

    ssize_t read(int fd,void * buf ,size_t count);

函数说明：
read()会把参数fd 所指的文件传送count个字节到buf指针所指的内存中。若参数count为0，则read()不会有作用并返回0。返回值为实际读取到的字节数，如果返回0，表示已到达文件尾或是无可读取的数据，此外文件读写位置会随读取到的字节移动。

Linux下文件描述符：

    Integer value	Name	<unistd.h> symbolic constant[1]	<stdio.h> file stream[2]
    0	Standard input	STDIN_FILENO	stdin
    1	Standard output	STDOUT_FILENO	stdout
    2	Standard error	STDERR_FILENO	stderr

# write函数

    ssize_t write(int fd,void * buf,size_t count)


# strcmp函数


# strlen函数

以\x00为截断，返回截止到\x00的数据长度，以字节为单位，例如：

\x00为一个字节


# open函数

参考：
[https://www.ibm.com/developerworks/community/blogs/58e72888-6340-46ac-b488-d31aa4058e9c/entry/understanding_linux_open_system_call?lang=en](https://www.ibm.com/developerworks/community/blogs/58e72888-6340-46ac-b488-d31aa4058e9c/entry/understanding_linux_open_system_call?lang=en)

文件操作

	int open(const char *path, int oflags);
	int open(const char *path, int oflags, mode_t mode);
	open("/home/mistake/password",O_RDONLY,0400) < 0 will return 0 (false) is the file is correctly loaded, therefore fd will always be 0.

操作标志位：

	O_RDONLY	Open the file so that it is read only.
	O_WRONLY	Open the file so that it is write only.
	O_RDWR	Open the file so that it can be read from and written to.
	O_APPEND	Append new information to the end of the file.
	O_TRUNC	Initially clear all data from the file.
	O_CREAT	If the file does not exist, create it. If the O_CREAT option is used, then you must include the third parameter.
	O_EXCL	Combined with the O_CREAT option, it ensures that the caller must create the file. If the file already exists, the call will fail.

模式：

	S_IRUSR	Set read rights for the owner to true.
	S_IWUSR	Set write rights for the owner to true.
	S_IXUSR	Set execution rights for the owner to true.
	S_IRGRP	Set read rights for the group to true.
	S_IWGRP	Set write rights for the group to true.
	S_IXGRP	Set execution rights for the group to true.
	S_IROTH	Set read rights for other users to true.
	S_IWOTH	Set write rights for other users to true.
	S_IXOTH	Set execution rights for other users to true.

	S_IRWXU 00700 user (file owner) has read, write and execute permission 
	S_IRUSR 00400 user has read permission 
	S_IWUSR 00200 user has write permission 
	S_IXUSR 00100 user has execute permission 
	S_IRWXG 00070 group has read, write and execute permission 
	S_IRGRP 00040 group has read permission 
	S_IWGRP 00020 group has write permission 
	S_IXGRP 00010 group has execute permission 
	S_IRWXO 00007 others have read, write and execute permission 
	S_IROTH 00004 others have read permission 
	S_IWOTH 00002 others have write permission 
	S_IXOTH 00001 others have execute permission




# fork函数

补充一道简单的面试题：

	#include <stdio.h>
	#include <sys/types.h>
	#include <unistd.h>
	 
	int main(void)
	{
	   int i;
	   for(i=0; i<2; i++){
	      fork();
	      printf("-");
	   }
	 
	   wait(NULL);
	   wait(NULL);
	 
	   return 0;
	}
	

会如何输出？ 答案是8个'-'，你或许会惊异，怎么不是6个'-'？问题的答案在于fork的机制

1. fork()系统调用是Unix下以自身进程创建子进程的系统调用，一次调用，两次返回，如果返回是0，则是子进程，如果返回值&gt;0，则是父进程（返回值是子进程的pid），这是众为周知的。
2. 在fork()的调用处，整个父进程空间会原模原样地复制到子进程中，包括指令，变量值，程序调用栈，环境变量，缓冲区，等等。
3. 上面的那个程序为什么会输入8个“-”，这是因为printf("-");语句有buffer，所以，对于上述程序，printf("-");把“-”放到了缓存中，并没有真正的输出。

C语言的谜题
https://coolshell.cn/articles/945.html
https://coolshell.cn/articles/7965.html


如何避免上面的问题，改成：

	printf("-");
	fflush(stdout);

就没有问题了（就是6个“-”了），因为程序遇到“\n”，或是EOF，或是缓中区满，或是文件描述符关闭，或是主动flush，或是程序退出，就会把数据刷出缓冲区。需要注意的是，标准输出是行缓冲，所以遇到“\n”的时候会刷出缓冲区，但对于磁盘这个块设备来说，“\n”并不会引起缓冲区刷出的动作，那是全缓冲，你可以使用setvbuf来设置缓冲区大小，或是用fflush刷缓存。
